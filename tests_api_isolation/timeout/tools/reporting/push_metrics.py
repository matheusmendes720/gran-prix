"""Utility to push timeout suite metrics to Prometheus Pushgateway or stdout.

Reads the latest run_suite_summary_*.json generated by tools/run_suite.py and
emits gauges for latency, success rate and exit codes for pytest, k6 and locust.
"""
from __future__ import annotations

import argparse
import json
import os
import sys
import time
from pathlib import Path
from typing import Any, Dict, Iterable, Tuple

import urllib.parse
import urllib.request

DEFAULT_SUMMARY_DIR = Path(__file__).resolve().parents[2] / "reports" / "raw"
DEFAULT_PUSHGATEWAY = "http://localhost:9091"
JOB_NAME = "timeout_isolation_suite"


def _find_latest_summary(summary_dir: Path) -> Path:
    summaries = sorted(summary_dir.glob("run_suite_summary_*.json"))
    if not summaries:
        raise FileNotFoundError(f"No run_suite_summary_*.json found in {summary_dir}")
    return summaries[-1]


def _load_summary(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


def _flatten_metrics(summary: Dict[str, Any]) -> Iterable[Tuple[str, float, Dict[str, str]]]:
    for tool_name, payload in summary.get("tools", {}).items():
        labels = {"tool": tool_name}
        exit_code = payload.get("exit_code")
        if exit_code is not None:
            yield "suite_exit_code", float(exit_code), labels
        duration = payload.get("duration_seconds")
        if duration is not None:
            yield "suite_duration_seconds", float(duration), labels
        success_rate = payload.get("success_rate")
        if success_rate is not None:
            yield "suite_success_rate", float(success_rate), labels

    pytest_payload = summary.get("pytest", {})
    if pytest_payload:
        labels = {"tool": "pytest"}
        for key in ("passed", "failed", "skipped"):
            value = pytest_payload.get(key)
            if value is not None:
                yield f"pytest_{key}_tests", float(value), labels


def _format_metrics(metrics: Iterable[Tuple[str, float, Dict[str, str]]]) -> str:
    lines = []
    timestamp = int(time.time())
    for metric, value, labels in metrics:
        label_str = ",".join(f"{k}={urllib.parse.quote(str(v))}" for k, v in labels.items())
        if label_str:
            line = f"{metric}{{{label_str}}} {value} {timestamp}"
        else:
            line = f"{metric} {value} {timestamp}"
        lines.append(line)
    return "\n".join(lines) + "\n"


def push_to_gateway(pushgateway_url: str, metrics_body: str, job: str) -> None:
    url = urllib.parse.urljoin(pushgateway_url.rstrip("/") + "/", f"metrics/job/{job}")
    req = urllib.request.Request(url, data=metrics_body.encode("utf-8"), method="PUT")
    req.add_header("Content-Type", "text/plain")
    with urllib.request.urlopen(req, timeout=10) as resp:  # nosec B310
        if resp.status >= 400:
            raise RuntimeError(f"Pushgateway responded with status {resp.status}")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Push timeout suite metrics to Pushgateway")
    parser.add_argument(
        "--summary-dir",
        type=Path,
        default=DEFAULT_SUMMARY_DIR,
        help="Directory containing run_suite_summary_*.json",
    )
    parser.add_argument("--pushgateway", default=DEFAULT_PUSHGATEWAY, help="Pushgateway URL")
    parser.add_argument(
        "--job-name",
        default=JOB_NAME,
        help="Job label used when pushing metrics",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print metrics to stdout instead of pushing",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    try:
        latest_summary = _find_latest_summary(args.summary_dir)
    except FileNotFoundError as exc:
        print(str(exc), file=sys.stderr)
        return 1

    summary = _load_summary(latest_summary)
    metrics = list(_flatten_metrics(summary))
    if not metrics:
        print("No metrics to push", file=sys.stderr)
        return 1

    body = _format_metrics(metrics)

    if args.dry_run:
        sys.stdout.write(body)
        return 0

    try:
        push_to_gateway(args.pushgateway, body, args.job_name)
    except Exception as exc:  # pylint: disable=broad-except
        print(f"Failed to push metrics: {exc}", file=sys.stderr)
        return 1

    print(f"Pushed metrics from {latest_summary.name} to {args.pushgateway}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
